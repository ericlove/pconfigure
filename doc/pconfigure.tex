\documentclass{article}
\usepackage{fullpage}
\usepackage{multicol}
\usepackage[pdfusetitle]{hyperref}

\newcommand{\pconfigure}{\texttt{pconfigure}}

\title{An Introduction to \pconfigure}
\author{Palmer Dabbelt}

\begin{document}
\maketitle
\begin{multicols}{2}
\tableofcontents
\end{multicols}
\clearpage

\section{Introduction}

\pconfigure\ is designed to be a replacement for GNU \texttt{autoconf}
and GNU \texttt{automake}.  \pconfigure\ reads a configuration file
(called a \texttt{Configfile}, like a \texttt{Makefile}) and generates
a \texttt{Makefile} that's suitable for processing by GNU
\texttt{make} -- in other words, \pconfigure\ fits into the same place
in the toolchain that the combination of \texttt{autoconf},
\texttt{automake}, and a run of \texttt{./configure} does.

Despite this, \pconfigure\ follows a significantly different design
philosophy than the GNU tools do: \pconfigure\ is designed to limit
the flexibility of the build system, while the GNU tools provide full
shell access at any point during the build configuration.
\pconfigure\ limits the flexibility of the build system in the hope
that \pconfigure\ configuration files from all projects will look
somewhat similar and will therefor be easier to understand for users
-- contrast this to the GNU tools, where each project's build
configuration files look very different and are therefor difficult to
understand.  The general idea is that \pconfigure\ is a build system,
while the GNU tools are a framework for creating your own,
project-specific build system.

\subsection{Building a project that uses \pconfigure}

If you're just trying to build a project that uses \pconfigure, you
should be able to run
\begin{verbatim}
$ cd PROJECT_SOURCE_DIRECTORY/
$ pconfigure
\end{verbatim}
and then proceed as if you would when runn the rest of the GNU
toolchain.  Specifically, running
\begin{verbatim}
$ make
$ make install
\end{verbatim}
will build the code and install it to the default installation
directory.  Additionally, you can run
\begin{verbatim}
$ make check
$ ptest
\end{verbatim}
to run the project's test cases and print the results of running those
test.  If you get errors while running \pconfigure, Section~\ref{err}
lists some commen errors and may be useful to help with
troubleshooting.  Additionally, Section~\ref{cl} contains a list of
command-line options that may be useful to you.

\subsection{Using \pconfigure\ in your project}

In order to use \pconfigure\ in your project you'll need a bit more
knowledge about how \pconfigure\ works.  The primary means by which
you'll be interacting with \pconfigure\ is by modifying it's
configuration file.  By default, \pconfigure\ will read
\texttt{Configfile} in the current working directory, parse every line
(until there is an aborting error), and then return.
\pconfigure\ configuration files are also refered to as
\texttt{Configfile}s, much the same way as \texttt{make} configuration
files are referred to as \texttt{Makefiles}s.

A \texttt{Configfile} file is line-oriented, and a \texttt{\#}
character at the beginning of a line signifies a comment, and blank
lines are ignored.  All other lines are of the format
\begin{verbatim}
COMMAND OPERATION VALUE
\end{verbatim}
where \texttt{COMMAND} is one of the options listed in
Sectien~\ref{cmd}; \texttt{OPERATION} is one of \texttt{-=},
\texttt{=}, or \texttt{+=}; and \texttt{VALUE} is a free-form text
value.  If \texttt{value} starts and ends with a \texttt{`} character
then it is executed as a shell out (the syntax here is just like BASH
and Ruby).

By default, the following configuration files are loaded in this order
\begin{verbatim}
Configfiles/local
Configfile.local
Configfiles/main
Configfile
\end{verbatim}
The general idea is that \texttt{*local} are configuration files that
should not be checked in to revision control because they're local to
a specific instance.  This is useful for setting things like
compile-time options that you want and other people don't (debug info,
for example).  The \texttt{Configfiles} directory is designed for
complicated projects that may have many configuration files, while
it's expected that simple projects will just use a singe configuration
file and call it \texttt{Configfile}.

Note that \pconfigure\ will silently skip any of these files that
don't exist so you only need to create the ones that make sense for
your project.  It's not expected that you make either
\texttt{Configfiles/local} or \texttt{Configfile.local} as these will
be specific to end-user systems.

\subsection{Writing your first \texttt{Configfile}}

The \texttt{Configfile} format is designed to be as terse as possible.
In order to achieve this there are a number of implicit rules that
\pconfigure\ uses to traverse your source tree and attempt to
determine exactly how you want your code built.  These rules depend on
exactly which language is currently being used, a list of which can be
found in Section~\ref{lang}.

\pconfigure\ was originally designed to link C code.  Most of the
other backends are at least partially based on the C backend which
makes C a good example for how to use \pconfigure, which is why this
example is written using C.  The same general structure applies to
\texttt{Configfile}s for all languages, but each language will handle
commands slightly differently so it's important to read
Section~\ref{lang} which will tell you exactly what your language is
expected to do.

A simple example \texttt{Configfile} for C is shown here
\begin{verbatim}
LANGUAGES   += c
COMPILEOPTS += -Wall

BINARIES    += hello
SOURCES     += hello.c
\end{verbatim}
I'll try to explain each line below.

\section{Command-Line Options \label{cl}}

The set of command-line arguments that \pconfigure\ understands is
stored in the \texttt{struct clopts} structure and is filled in
\texttt{clopts\_new()}.

\subsection{\texttt{--config <filename>}}

Loads a configuration file, see Section~\ref{cmd:config} for more
information.  Calling \texttt{--config <filename>} is exactly the same
as inserting a \texttt{CONFIG += <filename>} as the first line of your
\texttt{Configfile}.  Specifically, the configurations will be loaded
in the following order:

\begin{verbatim}
Configfiles/local
Configfile.local
Files listed by --config
Configfiles/main
Configfile
\end{verbatim}

\subsection{\texttt{--version}}

Prints the version number of \pconfigure\ and exits without touching
anything else.  Specifically, this doesn't touch the \texttt{Makefile}
at all.

\subsection{\texttt{--sourcepath <dirname>}}

Allows for the seperation of the source and build directories.  By
default, \pconfigure\ will place output file in the same directory as
the rest of your project, this allows them to be seperated.  Running
\begin{verbatim}
$ pconfigure --sourcepath $DIRNAME
\end{verbatim}
duplicates the functionality of running
\begin{verbatim}
$ $DIRNAME/configure
\end{verbatim}
in the land of GNU tools.

\subsection{\texttt{--binname}}

See Section~\ref{cl::srcname}, this is hard to describe in isolation.

\subsection{\texttt{--testname}}

See Section~\ref{cl::srcname}, this is hard to describe in isolation.

\subsection{\texttt{--srcname} \label{cl::srcname}}

The tree commands \texttt{--binname}, \texttt{--testname}, and
\texttt{--srcname} are all related and can only really be described
together.  The idea behind these is to allow interrogating a running
\pconfigure\ instance from inside the \texttt{Configfile}.

The general idea is that you can query the full name of an object that
\pconfigure\ builds.  You must provide either \texttt{--binname} or
\texttt{--testname} whenever you provide \texttt{--srcname}.  When you
pass \texttt{--srcname}, rather that outputting a \texttt{Makefile}
\pconfigure\ will print an object name to \texttt{stdout}.  The binary
name will coorespond to the object that gets built for the given
source and target name.

For example, if you have the configuration file
\begin{verbatim}
...
BINARIES += target
SOURCES  += source.c
...
\end{verbatim}
then running \texttt{pconfigure --binname target --srcname source.c}
will produce the object that pconfigure links into \texttt{bin/target}
when it compiles \texttt{src/source.c}.  This could be useful if you
need to interrogate this output from some script somewhere (for
example, from a \texttt{GENERATE} script).  Note that you can ask for
sources that are implicitly included in a binary.  The only difference
between providing \texttt{--testname} and \texttt{--binname} is that
\texttt{--testname} cooresponds to \texttt{TESTS} and
\texttt{--binname} cooresponds to \texttt{BINARIES}.

Note that passing any of these options disables \texttt{Makefile}
output by redirecting writes to \texttt{/dev/null}).  Additionally,
providing any of these arguments will disable any future calls to
shell outs, as otherwise a \texttt{Configfile} could recurse forever.

\section{Commands \label{cmd}}

\subsection{\texttt{LANGUAGES += \$lang}}

First, this flushes the current target.

If \texttt{LANGUAGES += \$lang} has not yet been run, then \$lang is
added to the list of known language backends.

\$lang is then set as the last added language.  This is used for two
distinct reasons: to manage exclusive languages, and to set
language-global command-line options.

The reason that all languages aren't just added to the language list
all the time is because some languages interact in odd ways.  An
example iss the interaction between C and C++ where C++ can build some
C files and C can build some C++ files: it would be impossible to
determine which compiler to use.  Another example is Scala and Chisel.

The other use of \texttt{LANGUAGES} is to set the ``last language
pointer'' so you can modify that language's language-global
command-line options.  For example, you may have
\begin{verbatim}
LANGUAGES += c
COMPILEOPTS += option1
...
LANGUAGES += c
COMPILEOPTS += option2
\end{verbatim}
when you want to build a whole bunch of targets with \texttt{option1},
and then want to build another set of targets with \texttt{option2}.
Overloading the whole \texttt{LANGUAGES} target to both add to the
language list and to set a pointer to the current language allows this
sort of behavior.

\subsection{\texttt{BINARIES}}

\subsection{\texttt{LIBRARIES += \$name}}

Largely the same as \texttt{BINARIES += \$name} with two major
differences: the resulting output binary is stored to
\texttt{\$LIBDIR} instead of \texttt{\$BINDIR} and a library is built
instead of a stand-alone binary.

Some amount of automatic detection is done in order to decide if a
shared or a static object should be built.  The hurestic is as
follows: if \$name ends in the canonical shared object extension on
Linux for the selected language (\texttt{*.so} on Linux, for example)
then a shared library will be used, if \$name ends in the canonical
static archive extension on Linux for the selected language
(\texttt{*.a} on Linux, for example) then a static archive will be
used, otherwise a fatal error will be throw.  This mechanism exists to
allow for cross-platform portability of \texttt{Configfile}s.

Note that \pconfigure\ will automatically determine the necessary
compiler flags to build shared objects on your platform.  For example,
Linux and C will result in \texttt{-fPIC} being appended to both the
compiler and linker flags.

\subsection{\texttt{LIBEXECS += \$name}}

Exactly the same as \texttt{BINARIES += \$name}, except that the
resulting output binary is stored to \texttt{\$LIBEXECDIR} instead of
\texttt{\$BINDIR}.

\subsection{\texttt{SOURCES}}

\subsection{\texttt{HEADERS}}

\subsection{\texttt{COMPILEOPTS += \$opt} \label{cmd:compileopts}}

\texttt{COMPILEOPTS} is used to change the compile-time options.  This
maps to the \texttt{CFLAGS} variable in the GNU toolchain.
\texttt{COMPILEOPTS} has different behavior depending on exactly which
state \pconfigure\ is in:

When \pconfigure\ has a current source, then the list of compile-time
options for just that source is appended with \texttt{\$opt}.

When \pconfigure\ has no current source but a current target, then the
list of compile-time options for all sources linked into that target
(both explicitly and implicitly) is append with \texttt{\$opt}.

When \pconfigure\ has no current source or target, then the list of
compile-time options for all sources built with the current languages
is appended with \texttt{\$opt}.

When \pconfigure\ has no current source, target, or language then a
fatal error is thrown.

\subsection{\texttt{LINKOPTS += \$opt}}

\texttt{LINKOPTS} is just like \texttt{COMPILEOPTS}, but it sets
linker options instead of compiler options (essentially it's
\texttt{LDFLAGS} in the GNU toolchain).  See
Section~\ref{cmd:compileopts} for a description of
\texttt{COMPILEOPTS}.

Note that some languages (Chisel, for example) have slightly different
semantics as to what's considered a compile-time option and what is
considered a link-time option.  Check Section~\ref{lang} for exactly
how your language interprets these argumuents.

For most languages (those that use standard compile and link
semantics), setting \texttt{LINKOPTS} for a source won't do anything,
you should instead set it on the target that source will be linked
into.

\subsection{\texttt{DEPLIBS += \$libname}}

Adds an internal library dependency to the list of link options.  This
is essentially the same as calling
\begin{verbatim}
LINKOPTS += -l$libname
\end{verbatim}
but it also adds a \texttt{Makefile} dependency such that whenever
\texttt{lib\$libname.so} is rebuilt the target this is attached to
will also be rebuilt.

\subsection{\texttt{TESTDEPS}}

\subsection{\texttt{TESTS}}

\subsection{\texttt{COMPILER}}

\subsection{\texttt{LINKER}}

\subsection{\texttt{PREFIX = \$prefix}}

Sets the \texttt{\$PREFIX} variable to \$prefix.

This works in the same manner as the \texttt{--prefix=\$prefix}
argument to GNU's toolchain does: it changes the directory in which
built files are expected to be installed.  There's no support for
things like \texttt{--bin-prefix}, instead binaries are installed to
\texttt{\$PREFIX/\$BINDIR}.  This keeps things consistant between the
installed image and the build directory's image.

Note that it's probably not sane to have \texttt{PREFIX} in the middle
of a \texttt{Configfile}.  See Section~\ref{err::prefix} for more
information.

\subsection{\texttt{LIBDIR}}

\subsection{\texttt{HDRDIR}}

\subsection{\texttt{TESTDIR}}

\subsection{\texttt{SRCDIR}}

\subsection{\texttt{CONFIG += \$file} \label{cmd:config}}

When \texttt{Configfiles/\$file} exists and is executable, the output
of that executable is treted as a \texttt{Configfile} and used as
input for \pconfigure.  When the executable terminates,
\pconfigure\ resumes parsing the current file at the next line.

When \texttt{Configfiles/\$file} exists and is not executable, that
file is parsed as a \texttt{Configfile} and used as the input for
\pconfigure.  When the executable terminates, \pconfigure\ resumes
parsing the current file at the next line.  This is effectively C's
\texttt{\#include} but for \pconfigure.

When \texttt{Configfiles/\$file} does not exist, a fatal error occurs.

\subsection{\texttt{TESTSRC += \$name}}

This is just a macro that generates
\begin{verbatim}
TESTS   += $name
SOURCES += $name
\end{verbatim}

\subsection{\texttt{GENERATE}}

\subsection{\texttt{TGENERATE += \$script}}

Exactly the same as generate, but runs \texttt{\$TESTDIR/\$script}
instead of running \texttt{\$SRCDIR/\$script}.

\section{Supported Languages \label{lang}}

A number of \pconfigure\ specifics are determined

\subsection{C}

\subsection{C++}

\subsection{BASH}

\subsection{Perl}

\subsection{\texttt{pkg-config}}

\subsection{Scala}

\subsection{Chisel (C++ backend)}

\subsection{Chisel (Flo backend)}

\section{Common Error Messages \label{err}}

\pconfigure\ will print a number of error messages to \texttt{stderr}.
Some of these messages are fatal and some aren't.  Fatal errors result
in the termination of \pconfigure\ without generating a valid
\texttt{Makefile}, while non-fatal errors are simply printed to
\texttt{stderr} while \pconfigure\ continues to run.  Note that some
non-fatal errors may mask or create others, so it's probably best to
only rely on the first error message (though this hasn't proved to be
a problem yet, it's a big problem with many other languages). %

\subsection{... failed, which is probably bad}

A shell-out exited with a non-zero exit code.  You should avoid using
commands that can fail but should instead handle these failures in
your code (ie, as opposed to your \texttt{Configfile}).

\section{Useful Helper Programs \label{prog}}

The \pconfigure\ distribution includes a number of binaries in
addition to the \pconfigure\ binary.  What follows is a list of these
programs along with a short description of their functionality and
usage.

\subsection{\texttt{pclean}}

The simplest helper program: essentially it just performs \texttt{rm
  *~} recursively.  It's just a small wrapper around \texttt{find}.

\subsection{\texttt{ptest}}

In addition to being used internally by \pconfigure\ to run tests,
\texttt{ptest} prints the current set of test results to
\texttt{stdout}.  You will almost certainly just want to run
\texttt{ptest} with no arguments, which will print the entire current
set of test results along with a summary.

\subsection{\texttt{pinclude}}

A small command-line tools that exposes \texttt{libpinclude.so},
\pconfigure's C preprocessor dependency handler, to BASH scripts.
This probably isn't actually useful because both \texttt{clang} and
\texttt{GCC} provide a more robust form of this functionality: the
only reason \texttt{libpinclude.so} exists in the first place is
because it's significantly faster than either of them.

\subsection{\texttt{ppkg-config}}

A wrapper around \texttt{pkg-config} that adds the following
command-line options:

\begin{itemize}
\item \texttt{--optional}: returns success regardless of whether the
  given \texttt{pkg-config} invocation succeeds or fails.
\item \texttt{--have \$name}: adds \texttt{-DHAVE\_\$name} to the
  compile-time arguments if the given \texttt{pkg-config} invocation
  succeeds, otherwise does nothing.
\end{itemize}

These two options combine to allow \texttt{pkg-config} to be
sufficient to do compile-time detection of features based on what is
currently installed on a system.  For example, the
\pconfigure\ \texttt{Configfile} uses the following snippit to decide
whether or not to use the system's talloc library or an internal
version based on which is availiable.

\begin{verbatim}
BINARIES    += pconfigure
COMPILEOPTS += `ppkg-config --optional --have TALLOC talloc --cflags`
LINKOPTS    += `ppkg-config --optional --have TALLOC talloc --libs`
SOURCES     += pconfigure/main.c
\end{verbatim}

\subsection{\texttt{pgcc-config}}

This allows \texttt{Configfile}s to interrogate the installed C
compilers by version number in an attempt to mask flags that are not
supported on particular compilers.

\subsection{\texttt{pllvm-config}}

A wrapper around \texttt{llvm-config} that does the same thing as
\texttt{ppkg-config}.

\subsection{\texttt{pbashc}}

A bash ``compiler'', which really just does the following
\begin{itemize}
\item Allows \texttt{\#include} (with the same semantics as in the C
  compiler) to be used from within BASH files.  This is a way to avoid
  \texttt{source}ing BASH files, which can be a pain when you don't
  know where they'll end up installed.
\item Sets the correct shebang at the beginning of the file
\item Marks the output as executable
\end{itemize}

\subsection{\texttt{pperlc}}

Exactly the same as \texttt{pbashc}, but for Perl files.

\subsection{\texttt{pscalac}}

When combined with \texttt{pscalald}, this makes Scala look like a
regular compiled language.  Specifically this wraps \texttt{scalac} in
a manner such that it produces a JAR archive, much like GCC produces
ELF objects.

\subsection{\texttt{pscalald}}

When combined with \texttt{pscalac}, this makes Scala look like a
regular compiled language.  Specifically, this allows the ``linking''
together of multiple Scala JAR archives into an ``executable''.  Here
``linking'' means just merging the ZIP files, and ``executable'' means
a self-extracting archive that then runs the result of its extraction
(and then cleans up after itself).

\subsection{\texttt{pnasm}}

A wrapper for NASM that makes it take a command-line argument syntax
that looks more like what GCC's assembler takes.  If you're looking to
make NASM a drop-in replacement for GAS in some build script, this may
be what you're after.

\subsection{\texttt{pwinegcc}}

A wrapper for the Wine project's modified GCC-based toolchain that
makes it behave in a manner more similar to stock GCC.  If you're
looking to make \texttt{winegcc} a drop-in replacement for
\texttt{gcc}, then this may be what you're after.

\section{Odd Behavior (ie, WONTFIX bugs) \label{odd}}

\pconfigure\ has some odd behaviors.  This section attempts to list
all of those behaviors and provide ana explination for them.  I'd
consider them all bugs, but fixing most of them will require imposing
some sort of breakage on some \texttt{Configfile}s, which I try to
avoid.

\subsection{Can't link C and C++ into one binary}

Building a single binary that consists of both C code compiled by
\texttt{\$(CC)} and C++ code compiled by \texttt{\$(CXX)} is flaky and
has a tendency to break between \pconfigure\ releases with pretty much
no warning.

This exists because the C++ backend allows C code to be built (as some
projects name their C++ source files \texttt{*.c}).  What this means
is that the C++ backend can't determine what is a C++ file and what is
a C file by looking at the filename alone.

The accepted workaround is to just build your C code with the C++
compiler when you're trying to link it with other C++ code.  This is
probably the safest thing to do anyway, as it avoids a bunch of
trouble related to C++ name mangling (though you'll have to fix that
to build a C library anyway, so it's not a strong argument).  This
workaround has the unfortunate consequence of requiring that you write
C code that can compile with a C++ compiler, which isn't always easy.

\subsection{Old Scala classes stick around}

Sometimes old Scala class files end up in the build output.

When you build a Scala binary or library, \pconfigure\ can't actually
determine which class files will be created.  Thus, it links every
class file that's in the Scala compiler's output directory into the
final binary.  If you make a source code change that causes a class
file to go away, an old version of it will still be in the output
directory and will therefor get linked in.

The way to fix this is to ``\texttt{make distclean; pconfigure;
  make}'', which clears out the whole cache.  This isn't ideal, but
I'd need to write a proper Scala parser to make this bug go away.

Note that this is kind of a regression: I used to run \texttt{strace}
to figure out which files the Scala compiler touched, but because
\texttt{zinc} runs in a background daemon I can't use that trick.  I
decided it'd be better to have \texttt{scalac} and \texttt{zinc}
produce exactly the same results rather than have \texttt{zinc}
sometimes break.

\subsection{\texttt{DEPLIBS} triggers a full rebuild}

When you depend on a library that's internal to this project by using
\texttt{DEPLIBS}, every dependency of that library will be rebuilt
whenever \pconfigure\ is run.

This is triggered because \pconfigure\ uses the library's short name
(ie, \texttt{lib/libLIB.so} as a dependency of theh binary when you
add a \texttt{DEPLIBS} command.  These short names all depend on
\texttt{Makefile} because of how the compiler flags hanling works.

Fixing this shouldn't actually be difficult: I believe we could just
depend on the full library name instead of the short library name, but
the easiest way to implement this would be to make some Configfiles
re-entrant that otherwise wouldn't be which will start to break things
in tricky ways.  A better way would be to store the long library names
for later, but that would require that all \texttt{LIBRARIES} commands
come before their relevant \texttt{DEPLIBS} commands, which is
probably the sanest way to do it.

\subsection{\texttt{PREFIX} must be the first line \label{err::prefix}}

The \texttt{PREFIX} variable is refered to twice: once when the
linking step is generated (to set \texttt{-rpath}, for example) and
once when the \texttt{make install} target is generated.  It's really
best if \texttt{\$PREFIX} is the same at both times, otherwise
unexpected things may happen.

\end{document}

